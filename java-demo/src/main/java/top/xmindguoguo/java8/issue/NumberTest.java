package top.xmindguoguo.java8.issue;

import java.util.LinkedHashSet;
import java.util.Set;

public class NumberTest {
    // 思路 地毯式 可能性 可能不存在这样的数
    // 第一先求这个整数的所有质数
    // 第二 将这个所有的质素进行配对相加 = 本身
    // 思路2 将一个数拆分成所有的数拆解为 数相加的形式 例如6=4+1+1 等等
    // 然后对这个所有的数集合进行校验 拆分为质数的相加，然后取集合长度最短的 利用set 去除重复

    // 思路三 本身是质数不算 num 代表输入的整数
    // 先判断这个数里面最大的质数是多少
    // 判断 num-最大质数 大于0 还是=0
    // =0 是本身 否定
    // 》0 取质数内最大的数进行相加 如果出现最大的质数+小于最大的质数相加《本身的情况下 排除 长度为2的可能 ，依次类推
    // 后面开始 最大质数+次一等质数+最小质数

    // 思路 输入一个整数 ，先求所有的质数 缓存到set 里面

    // 然后 把这些质数进行排序相加 等于 这个数的 进行 存放 到map key 是组合，value 是长度 ，然后map长度是总共多少组合，value最短的取出来就是最短的有几种组合

    public static void main(String[] args) {
        int num = 29; // 输入的数
        // 开始计算这个小于 整数的所有质数
        Set<Integer> primeSet = new LinkedHashSet<>(); // 保证从最大的顺序开始
        for (int i = num; i >= 2; i--) { // 1不是素数，所以直接从2开始循环
            int j = 2;
            while (i % j != 0) {
                j++; // 测试2至i的数字是否能被i整除，如不能就自加
            }
            if (j == i) {
                // 当有被整除的数字时，判断它是不是自身,若是，则说明是素数
                primeSet.add(i);
            }
        }
        // 转变成 求一个集合的所有数怎么排列相加 = num
        for (;;) {
            // 集合的数开始的几个大于num 证明只能这头几个数进行
        }
        // 然后输出所有的组合 和最短的组合

    }

    /*        public int f(int n) {
        return f1(n, 1) - 1; // 最顶层只有一个n不分不算
    }
    
    // 递归：按从小到底分割，用p限制
    public int f1(int n, int p, Set<Integer> primeSet) {
        int r = 0;
        if (n >= p)
            r = 1; // 直接用掉n算1种
    
        int i;
        for (i = p; i < primeSet.size(); i++) {
            r += f1(n - i, i, primeSet);
        }
        return r;
    }*/
}

/*用户输入任意一个整数，将其分解成若干个质数的加法求和，输出用数最少的所有可能

结栗出来（除目己）。

例：

29可拆解为

x29

V19+7+3

V17+11+1

V17+7+5

V13+11+5

x13+7+7+2

因此，29的最少质数求和（除目己）的长度为3,有4种可能组合.


---------------------------------我是可爱的页面分割线-------------------------------------
*/
